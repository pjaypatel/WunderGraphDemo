"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const merge_1 = require("./merge");
const index_1 = require("./index");
const chai_1 = require("chai");
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const userApi = new index_1.GraphQLApi("type Query @extends {   me: User } type User @key(fields: \"id\") {   id: ID!   name: String   username: String }", [
    {
        Kind: wundernode_config_1.DataSourceKind.GRAPHQL,
        RootNodes: [
            {
                typeName: "Query",
                fieldNames: [
                    "me"
                ]
            },
        ],
        ChildNodes: [
            {
                typeName: "User",
                fieldNames: [
                    "id", "name", "username"
                ]
            }
        ],
        Custom: {
            Federation: {
                Enabled: true,
                ServiceSDL: "type Query @extends {   me: User } type User @key(fields: \"id\") {   id: ID!   name: String   username: String }",
            },
            Subscription: {
                Enabled: false,
                URL: "",
            },
            Fetch: {
                url: "https://user.service",
                method: wundernode_config_1.HTTPMethod.POST,
                body: "",
                header: {},
                query: [],
                upstreamAuthentication: undefined,
            }
        }
    }
], []);
const productApi = new index_1.GraphQLApi("type Query @extends {   topProducts(first: Int = 5): [Product] }  type Product @key(fields: \"upc\") {   upc: String!   name: String   price: Int   weight: Int }", [
    {
        Kind: wundernode_config_1.DataSourceKind.GRAPHQL,
        RootNodes: [
            {
                typeName: "Query",
                fieldNames: [
                    "topProducts"
                ]
            },
        ],
        ChildNodes: [
            {
                typeName: "Product",
                fieldNames: [
                    "upc",
                    "name",
                    "price",
                    "weight"
                ]
            },
        ],
        Custom: {
            Federation: {
                Enabled: true,
                ServiceSDL: "type Query @extends {   topProducts(first: Int = 5): [Product] }  type Product @key(fields: \"upc\") {   upc: String!   name: String   price: Int   weight: Int }",
            },
            Subscription: {
                Enabled: false,
                URL: "",
            },
            Fetch: {
                url: "https://product.service",
                method: wundernode_config_1.HTTPMethod.POST,
                query: [],
                header: {},
                body: "",
                upstreamAuthentication: undefined,
            }
        }
    }
], [
    {
        typeName: "Query",
        fieldName: "topProducts",
        argumentsConfiguration: [
            {
                name: "first",
                sourceType: wundernode_config_1.ArgumentSource.FIELD_ARGUMENT,
                sourcePath: [],
            }
        ],
        requiresFields: [],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        disableDefaultFieldMapping: false,
    }
]);
const reviewsApi = new index_1.GraphQLApi("type Review @key(fields: \"id\") {   id: ID!   body: String   author: User @provides(fields: \"username\")   product: Product }  type User @extends @key(fields: \"id\") {   id: ID! @external   username: String @external   reviews: [Review] }  type Product @extends @key(fields: \"upc\") {   upc: String! @external   reviews: [Review] } ", [
    {
        Kind: wundernode_config_1.DataSourceKind.GRAPHQL,
        RootNodes: [
            {
                typeName: "User",
                fieldNames: [
                    "reviews"
                ]
            },
            {
                typeName: "Product",
                fieldNames: [
                    "reviews"
                ]
            }
        ],
        ChildNodes: [
            {
                typeName: "Review",
                fieldNames: [
                    "id",
                    "body",
                    "author",
                    "product"
                ]
            },
            {
                typeName: "User",
                fieldNames: [
                    "id",
                ]
            },
            {
                typeName: "Product",
                fieldNames: [
                    "upc"
                ]
            }
        ],
        Custom: {
            Federation: {
                Enabled: true,
                ServiceSDL: "type Review @key(fields: \"id\") {   id: ID!   body: String   author: User @provides(fields: \"username\")   product: Product }  type User @extends @key(fields: \"id\") {   id: ID! @external   username: String @external   reviews: [Review] }  type Product @extends @key(fields: \"upc\") {   upc: String! @external   reviews: [Review] }",
            },
            Subscription: {
                Enabled: false,
                URL: "",
            },
            Fetch: {
                url: "https://reviews.service",
                method: wundernode_config_1.HTTPMethod.POST,
                body: "",
                header: {},
                query: [],
                upstreamAuthentication: undefined,
            }
        }
    }
], [
    {
        typeName: "User",
        fieldName: "reviews",
        requiresFields: [
            "id"
        ],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        argumentsConfiguration: [],
        disableDefaultFieldMapping: false,
    },
    {
        typeName: "Product",
        fieldName: "reviews",
        requiresFields: [
            "upc"
        ],
        argumentsConfiguration: [],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        disableDefaultFieldMapping: false,
    }
]);
const inventoryApi = new index_1.GraphQLApi("type Product @extends @key(fields: \"upc\") {     upc: String! @external     weight: Int @external     price: Int @external     inStock: Boolean     shippingEstimate: Int @requires(fields: \"price weight\") } ", [
    {
        Kind: wundernode_config_1.DataSourceKind.GRAPHQL,
        RootNodes: [
            {
                typeName: "Product",
                fieldNames: [
                    "inStock",
                    "shippingEstimate"
                ]
            }
        ],
        ChildNodes: [
            {
                typeName: "Product",
                fieldNames: [
                    "upc"
                ]
            }
        ],
        Custom: {
            Federation: {
                Enabled: true,
                ServiceSDL: "type Product @extends @key(fields: \"upc\") {     upc: String! @external     weight: Int @external     price: Int @external     inStock: Boolean     shippingEstimate: Int @requires(fields: \"price weight\") }",
            },
            Subscription: {
                Enabled: false,
                URL: "",
            },
            Fetch: {
                url: "https://inventory.service",
                method: wundernode_config_1.HTTPMethod.POST,
                query: [],
                header: {},
                body: "",
                upstreamAuthentication: undefined,
            }
        }
    }
], [
    {
        typeName: "Product",
        fieldName: "inStock",
        requiresFields: [
            "upc"
        ],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        argumentsConfiguration: [],
        disableDefaultFieldMapping: false,
    },
    {
        typeName: "Product",
        fieldName: "shippingEstimate",
        requiresFields: [
            "upc"
        ],
        argumentsConfiguration: [],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        disableDefaultFieldMapping: false,
    }
]);
const expectedSchema = `directive @fromClaim(name: Claim) on VARIABLE_DEFINITION

type Query {
  me: User
  topProducts(first: Int = 5): [Product]
}

type User {
  id: ID!
  name: String
  username: String
  reviews: [Review]
}

type Product {
  upc: String!
  name: String
  price: Int
  weight: Int
  reviews: [Review]
  inStock: Boolean
  shippingEstimate: Int
}

type Review {
  id: ID!
  body: String
  author: User
  product: Product
}

enum Claim {
  EMAIL
  EMAIL_VERIFIED
  NAME
  NICKNAME
  LOCATION
  PROVIDER
}
`;
const expected = new index_1.Api(expectedSchema, [
    ...userApi.DataSources,
    ...productApi.DataSources,
    ...reviewsApi.DataSources,
    ...inventoryApi.DataSources,
], [
    {
        typeName: "Query",
        fieldName: "topProducts",
        argumentsConfiguration: [
            {
                name: "first",
                sourceType: wundernode_config_1.ArgumentSource.FIELD_ARGUMENT,
                sourcePath: [],
            }
        ],
        requiresFields: [],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        disableDefaultFieldMapping: false,
    },
    {
        typeName: "User",
        fieldName: "reviews",
        requiresFields: [
            "id"
        ],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        argumentsConfiguration: [],
        disableDefaultFieldMapping: false,
    },
    {
        typeName: "Product",
        fieldName: "reviews",
        requiresFields: [
            "upc"
        ],
        argumentsConfiguration: [],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        disableDefaultFieldMapping: false,
    },
    {
        typeName: "Product",
        fieldName: "inStock",
        requiresFields: [
            "upc"
        ],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        argumentsConfiguration: [],
        disableDefaultFieldMapping: false,
    },
    {
        typeName: "Product",
        fieldName: "shippingEstimate",
        requiresFields: [
            "upc"
        ],
        argumentsConfiguration: [],
        respectOverrideFieldPathFromAlias: true,
        path: [],
        disableDefaultFieldMapping: false,
    }
]);
test("merge", () => {
    const actual = merge_1.mergeApis(userApi, productApi, reviewsApi, inventoryApi);
    chai_1.assert.equal(pretty(actual), pretty(expected));
});
const pretty = (input) => {
    return JSON.stringify(input, null, "  ");
};
