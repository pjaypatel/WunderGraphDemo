"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.baseSchema = exports.mergeApis = void 0;
const index_1 = require("./index");
const graphql_1 = require("graphql");
const merge_1 = require("@graphql-tools/merge");
const mergeApis = (...apis) => {
    const dataSources = apis
        .map(api => api.DataSources)
        .reduce((previousValue, currentValue) => ([...previousValue, ...currentValue]));
    const fields = mergeApiFields(apis);
    const schema = mergeApiSchemas(apis);
    return new index_1.Api(schema, dataSources, fields);
};
exports.mergeApis = mergeApis;
const mergeApiFields = (apis) => {
    const fields = [];
    apis.map(a => a.Fields).reduce((previousValue, currentValue) => ([...previousValue, ...currentValue])).forEach(f => {
        const existing = fields.find(existing => existing.typeName === f.typeName && existing.fieldName === f.fieldName);
        if (!existing) {
            fields.push(f);
            return;
        }
        if (f.requiresFields) {
            existing.requiresFields = [...new Set([...existing.requiresFields || [], ...f.requiresFields])];
        }
        if (f.argumentsConfiguration) {
            existing.argumentsConfiguration = existing.argumentsConfiguration || [];
            f.argumentsConfiguration.forEach(a => {
                const exists = existing.argumentsConfiguration.find(e => e.name === a.name) !== undefined;
                if (exists) {
                    return;
                }
                existing.argumentsConfiguration.push(a);
            });
        }
    });
    return fields;
};
exports.baseSchema = `
directive @fromClaim(
  name: Claim
) on VARIABLE_DEFINITION

enum Claim {
  EMAIL
  EMAIL_VERIFIED
  NAME
  NICKNAME
  LOCATION
  PROVIDER
}`;
const mergeApiSchemas = (apis) => {
    const graphQLSchemas = apis.map((api, i) => {
        return graphql_1.buildSchema(api.Schema, {
            assumeValidSDL: true,
        });
    });
    graphQLSchemas.push(graphql_1.buildSchema(exports.baseSchema, {
        assumeValidSDL: true
    }));
    const mergedGraphQLSchema = merge_1.mergeSchemas({
        schemas: graphQLSchemas,
        assumeValid: true,
    });
    const printed = graphql_1.printSchema(mergedGraphQLSchema);
    const ast = graphql_1.parse(printed);
    const filtered = graphql_1.visit(ast, {
        ObjectTypeDefinition: node => {
            if (node.name.value.startsWith("_")) {
                return null;
            }
            switch (node.name.value) {
                case "Entity":
                    return null;
            }
        },
        UnionTypeDefinition: node => {
            if (node.name.value.startsWith("_")) {
                return null;
            }
        },
        ScalarTypeDefinition: node => {
            if (node.name.value.startsWith("_")) {
                return null;
            }
        },
        FieldDefinition: node => {
            if (node.name.value.startsWith("_")) {
                return null;
            }
        },
        DirectiveDefinition: node => {
            switch (node.name.value) {
                case "key":
                case "extends":
                case "external":
                case "requires":
                case "provides":
                    return null;
            }
        }
    });
    const withoutEmptyDescription = removeEmptyDescriptions(filtered);
    return graphql_1.print(withoutEmptyDescription);
};
const removeEmptyDescriptions = (astNode) => {
    return graphql_1.visit(astNode, {
        enter: node => {
            switch (node.kind) {
                case "ObjectTypeDefinition":
                case "ScalarTypeDefinition":
                case "InterfaceTypeDefinition":
                case "UnionTypeDefinition":
                case "FieldDefinition":
                    if (node.description && node.description.value === "") {
                        return {
                            ...node,
                            description: undefined,
                        };
                    }
            }
        }
    });
};
