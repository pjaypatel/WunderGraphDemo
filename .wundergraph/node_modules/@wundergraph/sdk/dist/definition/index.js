"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildUpstreamAuthentication = exports.introspect = exports.IntrospectionPolicy = exports.MySQLApi = exports.PostgresqlApi = exports.RESTApi = exports.GraphQLApi = exports.Api = exports.Application = void 0;
const federation_1 = require("../graphql/federation");
const configuration_1 = require("../graphql/configuration");
const graphql_1 = require("graphql");
const merge_1 = require("./merge");
const fs = __importStar(require("fs"));
const v2openapi_1 = require("../v2openapi");
const renametypes_1 = require("../graphql/renametypes");
const axios_1 = __importDefault(require("axios"));
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const schema_1 = require("../graphql/schema");
const path_1 = __importDefault(require("path"));
const introspection_1 = require("../db/introspection");
class Application {
    constructor(config) {
        this.enable_singleflight = true;
        this.name = config.name;
        this.apis = config.apis;
    }
}
exports.Application = Application;
class Api {
    constructor(schema, dataSources, fields) {
        this.DefaultFlushInterval = 500;
        this.Schema = schema;
        this.DataSources = dataSources;
        this.Fields = fields;
    }
    renameTypes(rename) {
        this.Schema = renametypes_1.renameTypes(this.Schema, rename);
        this.DataSources = this.DataSources.map(d => {
            return {
                ...d,
                RootNodes: typeFieldsRenameType(d.RootNodes, rename),
                ChildNodes: typeFieldsRenameType(d.ChildNodes, rename),
            };
        });
        this.Fields = this.Fields.map(field => {
            const re = rename.find(r => r.from === field.typeName);
            return {
                ...field,
                typeName: re !== undefined ? re.to : field.typeName
            };
        });
    }
    renameTypeFields(rename) {
        this.Schema = renametypes_1.renameTypeFields(this.Schema, rename);
        this.DataSources = this.DataSources.map(d => {
            return {
                ...d,
                RootNodes: typeFieldsRenameTypeField(d.RootNodes, rename),
                ChildNodes: typeFieldsRenameTypeField(d.ChildNodes, rename),
            };
        });
        this.Fields = this.Fields.map(field => {
            const re = rename.find(re => re.typeName === field.typeName && re.fromFieldName === field.fieldName);
            if (re !== undefined) {
                return {
                    ...field,
                    fieldName: re.toFieldName,
                    path: field.path.map(item => item === field.fieldName ? re.toFieldName : item),
                };
            }
            const sameTypeRenameFields = rename.filter(re => re.typeName === field.typeName);
            return {
                ...field,
                requiresFields: field.requiresFields.map(f => {
                    const re = sameTypeRenameFields.find(sameTypeField => sameTypeField.fromFieldName === f);
                    if (re !== undefined) {
                        return re.toFieldName;
                    }
                    return f;
                }),
                argumentsConfiguration: field.argumentsConfiguration.map(arg => {
                    if (arg.sourceType === wundernode_config_1.ArgumentSource.OBJECT_FIELD) {
                        return {
                            ...arg,
                            sourcePath: arg.sourcePath.map(item => {
                                const re = sameTypeRenameFields.find(sameTypeField => sameTypeField.fromFieldName === item);
                                if (re !== undefined) {
                                    return re.toFieldName;
                                }
                                return item;
                            })
                        };
                    }
                    return arg;
                })
            };
        });
    }
}
exports.Api = Api;
const typeFieldsRenameType = (fields, rename) => {
    return fields.map(node => {
        const re = rename.find(r => r.from === node.typeName);
        return {
            ...node,
            typeName: re !== undefined ? re.to : node.typeName
        };
    });
};
const typeFieldsRenameTypeField = (fields, rename) => {
    return fields.map(node => {
        return {
            ...node,
            fieldNames: node.fieldNames.map(field => {
                const re = rename.find(re => re.typeName === node.typeName && re.fromFieldName === field);
                if (re !== undefined) {
                    return re.toFieldName;
                }
                return field;
            })
        };
    });
};
class GraphQLApi extends Api {
}
exports.GraphQLApi = GraphQLApi;
class RESTApi extends Api {
}
exports.RESTApi = RESTApi;
class PostgresqlApi extends Api {
}
exports.PostgresqlApi = PostgresqlApi;
class MySQLApi extends Api {
}
exports.MySQLApi = MySQLApi;
var IntrospectionPolicy;
(function (IntrospectionPolicy) {
    IntrospectionPolicy["CacheOrNetwork"] = "CacheOrNetwork";
    IntrospectionPolicy["Cache"] = "Cache";
    IntrospectionPolicy["Network"] = "Network";
})(IntrospectionPolicy = exports.IntrospectionPolicy || (exports.IntrospectionPolicy = {}));
exports.introspect = {
    graphql: async (introspection) => {
        switch (introspection.source) {
            case IntrospectionPolicy.Network:
                const schema = await introspectGraphQLAPI(introspection.url, introspection.headers);
                const schemaSDL = graphql_1.printSchema(schema_1.cleanupSchema(schema));
                const federationEnabled = federation_1.isFederationService(schema);
                const serviceSDL = !federationEnabled ? undefined : await federation_1.federationServiceSDL(introspection.url);
                const serviceDocumentNode = serviceSDL !== undefined ? graphql_1.parse(serviceSDL) : undefined;
                const schemaDocumentNode = graphql_1.parse(schemaSDL);
                const { RootNodes, ChildNodes, Fields } = configuration_1.configuration(schemaDocumentNode, serviceDocumentNode);
                const subscriptionsEnabled = hasSubscriptions(schema);
                const header = {};
                Object.keys(introspection.headers || {}).forEach(key => {
                    header[key] = {
                        values: [introspection.headers[key]]
                    };
                });
                return new GraphQLApi(schemaSDL, [
                    {
                        Kind: wundernode_config_1.DataSourceKind.GRAPHQL,
                        RootNodes,
                        ChildNodes,
                        Custom: {
                            Fetch: {
                                url: introspection.url,
                                method: wundernode_config_1.HTTPMethod.POST,
                                body: "",
                                header: header,
                                query: [],
                                upstreamAuthentication: exports.buildUpstreamAuthentication(introspection)
                            },
                            Subscription: {
                                Enabled: subscriptionsEnabled,
                                URL: subscriptionsEnabled ? subscriptionsURL(introspection.url) : "",
                            },
                            Federation: {
                                Enabled: federationEnabled,
                                ServiceSDL: serviceSDL || "",
                            }
                        }
                    }
                ], Fields);
        }
        throw new Error("introspect: graphql failed");
    },
    postgresql: async (introspection) => {
        const { success, graphql_schema, prisma_schema, message } = introspection_1.IntrospectPostgresDatabase(introspection.database_querystring);
        if (!success) {
            throw new Error(`introspection failed: ${message}`);
        }
        const schemaDocumentNode = graphql_1.parse(graphql_schema);
        const schema = graphql_1.print(schemaDocumentNode);
        const { RootNodes, ChildNodes, Fields } = configuration_1.configuration(schemaDocumentNode);
        return new PostgresqlApi(schema, [
            {
                Kind: wundernode_config_1.DataSourceKind.POSTGRESQL,
                RootNodes: RootNodes,
                ChildNodes: ChildNodes,
                Custom: {
                    prisma_schema: prisma_schema,
                    database_querystring: introspection.database_querystring,
                    graphql_schema: schema,
                }
            }
        ], Fields);
    },
    mysql: async (introspection) => {
        const { success, graphql_schema, prisma_schema, message } = introspection_1.IntrospectMySQLDatabase(introspection.database_querystring);
        if (!success) {
            throw new Error(`introspection failed: ${message}`);
        }
        const schemaDocumentNode = graphql_1.parse(graphql_schema);
        const schema = graphql_1.print(schemaDocumentNode);
        const { RootNodes, ChildNodes, Fields } = configuration_1.configuration(schemaDocumentNode);
        return new MySQLApi(schema, [
            {
                Kind: wundernode_config_1.DataSourceKind.MYSQL,
                RootNodes: RootNodes,
                ChildNodes: ChildNodes,
                Custom: {
                    prisma_schema: prisma_schema,
                    database_querystring: introspection.database_querystring,
                    graphql_schema: schema,
                }
            }
        ], Fields);
    },
    federation: async (introspection) => {
        const graphQLIntrospections = introspection.upstreams.map(upstream => ({
            url: upstream.url,
            headers: upstream.headers,
            source: introspection.source,
        }));
        const apis = await Promise.all(graphQLIntrospections.map(i => exports.introspect.graphql(i)));
        return merge_1.mergeApis(...apis);
    },
    openApi: async (introspection) => {
        const spec = loadOpenApi(introspection);
        return await v2openapi_1.openApiSpecificationToRESTApiObject(spec, introspection);
    }
};
const buildUpstreamAuthentication = (upstream) => {
    if (upstream.authentication === undefined) {
        return undefined;
    }
    return {
        kind: upstreamAuthenticationKind(upstream.authentication.kind),
        jwtConfig: upstream.authentication.kind === "jwt" ? {
            secret: upstream.authentication.secret,
            signingMethod: upstreamAuthenticationSigningMethod(upstream.authentication.signingMethod),
        } : undefined,
        jwtWithAccessTokenExchangeConfig: upstream.authentication.kind === "jwt_with_access_token_exchange" ? {
            accessTokenExchangeEndpoint: upstream.authentication.accessTokenExchangeEndpoint,
            secret: upstream.authentication.secret,
            signingMethod: upstreamAuthenticationSigningMethod(upstream.authentication.signingMethod),
        } : undefined,
    };
};
exports.buildUpstreamAuthentication = buildUpstreamAuthentication;
const upstreamAuthenticationSigningMethod = (signingMethod) => {
    switch (signingMethod) {
        case "HS256":
            return wundernode_config_1.SigningMethod.SigningMethodHS256;
        default:
            throw new Error(`JWT signing method unsupported: ${signingMethod}`);
    }
};
const upstreamAuthenticationKind = (kind) => {
    switch (kind) {
        case "jwt":
            return wundernode_config_1.UpstreamAuthenticationKind.UpstreamAuthenticationJWT;
        case "jwt_with_access_token_exchange":
            return wundernode_config_1.UpstreamAuthenticationKind.UpstreamAuthenticationJWTWithAccessTokenExchange;
        default:
            throw new Error(`upstreamAuthenticationKind, unsupported kind: ${kind}`);
    }
};
const introspectGraphQLAPI = async (url, headers) => {
    const data = JSON.stringify({
        query: graphql_1.getIntrospectionQuery(),
        operationName: "IntrospectionQuery"
    });
    const res = await axios_1.default.post(url, data, {
        headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...headers || {},
        }
    });
    if (res.status !== 200) {
        return Promise.reject(`introspection failed, response code: ${res.status}, message: ${res.statusText}`);
    }
    return graphql_1.buildClientSchema(res.data.data);
};
const loadOpenApi = (introspection) => {
    switch (introspection.source.kind) {
        case "file":
            const filePath = path_1.default.resolve(process.cwd(), introspection.source.filePath);
            return fs.readFileSync(filePath).toString();
        case "object":
            return JSON.stringify(introspection.source.openAPIObject);
        case "string":
            return introspection.source.openAPISpec;
        default:
            return "";
    }
};
const hasSubscriptions = (schema) => {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return false;
    }
    const fields = subscriptionType.getFields();
    return Object.keys(fields).length !== 0;
};
const subscriptionsURL = (url) => url
    .replace("https://", "wss://")
    .replace("http://", "ws://");
