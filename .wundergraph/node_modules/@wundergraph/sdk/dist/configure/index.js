"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureWunderGraphApplication = void 0;
const fs_1 = __importDefault(require("fs"));
const merge_1 = require("../definition/merge");
const dotgraphqlconfig_1 = require("../dotgraphqlconfig");
const operations_1 = require("../graphql/operations");
const codegen_1 = require("../codegen");
//import chokidar from "chokidar"
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const fastify_1 = __importDefault(require("fastify"));
const get_port_1 = __importDefault(require("get-port"));
const version_1 = require("../version");
const linkbuilder_1 = require("../linkbuilder");
const graphql_1 = require("graphql");
const resolveConfig = async (config) => {
    const api = config.deployment ? config.deployment.api.apiConfig() : {
        id: "",
        name: "api"
    };
    const environment = config.deployment ? config.deployment.environment.environmentConfig() : {
        id: "",
        name: "localhost:9991",
    };
    const name = config.deployment ? config.deployment.name : "main";
    const deploymentConfiguration = {
        api,
        environment,
        name,
        path: api.name + "/" + name,
    };
    const cors = {
        ...config.cors,
        allowedOrigins: config.cors.allowedOrigins.map(origin => {
            if (origin.endsWith("/")) {
                return origin.substring(0, origin.length - 1);
            }
            return origin;
        }),
    };
    const resolved = await resolveApplications([config.application], cors);
    const cookieBasedAuthProviders = config.authentication !== undefined &&
        config.authentication.cookieBased !== undefined &&
        config.authentication.cookieBased.providers.map(provider => provider.resolve()) || [];
    const resolvedConfig = {
        application: resolved[0],
        deployment: deploymentConfiguration,
        sdkVersion: version_1.SDK_VERSION,
        authentication: {
            cookieBased: cookieBasedAuthProviders,
        },
        enableGraphQLEndpoint: config.deployment !== undefined && config.deployment.dangerouslyEnableGraphQLEndpoint === true,
    };
    if (config.links) {
        return addLinks(resolvedConfig, config.links);
    }
    return resolvedConfig;
};
const addLinks = (config, links) => {
    const schema = graphql_1.buildSchema(config.application.EngineConfiguration.Schema);
    const queryTypeName = (schema.getQueryType() || { name: "" }).name;
    const fields = linkbuilder_1.queryTypeFields(schema);
    links.forEach(link => {
        config = addLink(config, link, fields, queryTypeName);
    });
    return config;
};
const addLink = (config, link, fields, queryTypeName) => {
    const schema = graphql_1.parse(config.application.EngineConfiguration.Schema);
    let fieldInfo;
    config.application.EngineConfiguration.Schema = graphql_1.print(graphql_1.visit(schema, {
        ObjectTypeDefinition: node => {
            if (node.name.value !== link.targetType) {
                return;
            }
            if ((node.fields || []).find(field => field.name.value === link.targetFieldName)) {
                return;
            }
            fieldInfo = fields.find(field => field.typeName === queryTypeName && field.fieldName === link.sourceField);
            if (fieldInfo === undefined) {
                return;
            }
            fieldInfo.arguments.forEach(expected => {
                const exists = link.argumentSources.find(actual => actual.name === expected.name) !== undefined;
                if (!exists) {
                    console.log(`configuration missing for argument: ${expected.name} on targetField: ${link.targetFieldName} on targetType: ${link.targetType}`);
                    console.log("please add '.argument(\"towerIds\", ...)' to the linkBuilder or the resolver will not be configured properly");
                }
            });
            const args = link
                .argumentSources
                .filter(arg => arg.type === "fieldArgument")
                .map(arg => {
                const argumentDefinition = fieldInfo.arguments.find(definition => definition.name === arg.name);
                if (argumentDefinition === undefined) {
                    throw Error(`argument with name ${arg.name} doesn't exist on source field: ${fieldInfo.fieldName}@${fieldInfo.typeName}`);
                }
                return {
                    kind: "InputValueDefinition",
                    name: {
                        kind: "Name",
                        value: arg.name,
                    },
                    type: graphql_1.parseType(argumentDefinition.type),
                };
            });
            const field = {
                kind: "FieldDefinition",
                name: {
                    kind: "Name",
                    value: link.targetFieldName
                },
                type: graphql_1.parseType(fieldInfo.fieldType),
                arguments: args.length !== 0 ? args : undefined,
            };
            return {
                ...node,
                fields: [
                    ...node.fields || [],
                    field,
                ]
            };
        }
    }));
    if (fieldInfo !== undefined) {
        const fieldConfiguration = config.application.EngineConfiguration.Fields.find(field => field.typeName === fieldInfo.typeName && field.fieldName === fieldInfo.fieldName);
        if (fieldConfiguration === undefined) {
            throw new Error(`fieldConfiguration not found for type: ${fieldInfo.typeName}, field: ${fieldInfo.fieldName}`);
        }
        const copy = Object.assign({}, fieldConfiguration, {
            fieldName: link.targetFieldName,
            typeName: link.targetType,
            argumentsConfiguration: []
        });
        link.argumentSources.forEach(arg => {
            copy.argumentsConfiguration.push({
                name: arg.name,
                sourceType: arg.type === "objectField" ? wundernode_config_1.ArgumentSource.OBJECT_FIELD : wundernode_config_1.ArgumentSource.FIELD_ARGUMENT,
                sourcePath: arg.path
            });
        });
        config.application.EngineConfiguration.Fields.push(copy);
        const dataSource = config.application.EngineConfiguration.DataSources.find(ds => ds.RootNodes.find(node => node.typeName === queryTypeName && node.fieldNames.find(field => field === link.sourceField)) !== undefined);
        if (dataSource === undefined) {
            throw new Error(`dataSource not found for type: ${fieldInfo.typeName}, field: ${fieldInfo.fieldName}`);
        }
        const ds = Object.assign({}, dataSource);
        ds.RootNodes = ds.RootNodes.map(node => {
            if (node.typeName === queryTypeName) {
                return {
                    typeName: link.targetType,
                    fieldNames: [...node.fieldNames.filter(field => field !== link.sourceField), link.targetFieldName]
                };
            }
            else {
                return node;
            }
        });
        ds.ChildNodes = ds.ChildNodes.map(node => {
            if (node.typeName === queryTypeName) {
                return {
                    typeName: link.targetType,
                    fieldNames: [...node.fieldNames.filter(field => field !== link.sourceField), link.targetFieldName]
                };
            }
            else {
                return node;
            }
        });
        const withUpdatedArguments = updateArguments(ds, fieldInfo, link);
        config.application.EngineConfiguration.DataSources.push(withUpdatedArguments);
    }
    return config;
};
const updateArguments = (dataSource, fieldInfo, link) => {
    let json = JSON.stringify(dataSource);
    fieldInfo.arguments.forEach(arg => {
        const source = link.argumentSources.find(source => source.name === arg.name);
        if (source === undefined) {
            return;
        }
        const search = `.arguments.${arg.name}`;
        const path = source.path.join(".");
        const replace = source.type === "objectField" ? `.object.${path}` : `.arguments.${path}`;
        json = json.replace(search, replace);
    });
    return JSON.parse(json);
};
const resolveApplications = async (applications, cors) => {
    const out = [];
    for (let i = 0; i < applications.length; i++) {
        const resolvedApis = await Promise.all(applications[i].apis);
        const merged = merge_1.mergeApis(...resolvedApis);
        out.push({
            Name: applications[i].name,
            EngineConfiguration: merged,
            EnableSingleFlight: true,
            Operations: [],
            CorsConfiguration: cors,
        });
    }
    return out;
};
const configureWunderGraphApplication = (config) => {
    const outFile = config.outFile || "wundergraph.config.json";
    const isProduction = process.env.NODE_ENV === "production";
    resolveConfig(config).then(async (resolved) => {
        const app = resolved.application;
        const schemaFileName = `wundergraph.${app.Name}.schema.graphql`;
        fs_1.default.writeFile(schemaFileName, app.EngineConfiguration.Schema, err => {
            if (err != null) {
                console.log(err);
                return;
            }
        });
        const operationsContent = operations_1.loadOperations();
        const operations = operations_1.parseOperations(app.EngineConfiguration.Schema, operationsContent.toString());
        app.Operations = operations.operations;
        if (app.Operations && config.operations !== undefined) {
            app.Operations = app.Operations.map(op => {
                const cfg = config.operations;
                const base = Object.assign({}, cfg.defaultConfig);
                const customize = (cfg.custom !== undefined && cfg.custom[op.Name] !== undefined) ? cfg.custom[op.Name] : undefined;
                switch (op.OperationType) {
                    case wundernode_config_1.OperationType.MUTATION:
                        let mutationConfig = cfg.mutations(base);
                        if (customize) {
                            mutationConfig = customize(mutationConfig);
                        }
                        return {
                            ...op,
                            AuthenticationConfig: {
                                ...op.AuthenticationConfig,
                                required: mutationConfig.authentication.required,
                            }
                        };
                    case wundernode_config_1.OperationType.QUERY:
                        let queryConfig = cfg.queries(base);
                        if (customize) {
                            queryConfig = customize(queryConfig);
                        }
                        return {
                            ...op,
                            CacheConfig: {
                                enable: queryConfig.caching.enable,
                                maxAge: queryConfig.caching.maxAge,
                                public: queryConfig.caching.public,
                                staleWhileRevalidate: queryConfig.caching.staleWhileRevalidate,
                            },
                            AuthenticationConfig: {
                                ...op.AuthenticationConfig,
                                required: queryConfig.authentication.required
                            },
                            LiveQuery: {
                                enable: queryConfig.liveQuery.enable,
                                pollingIntervalSeconds: queryConfig.liveQuery.pollingIntervalSeconds,
                            }
                        };
                    case wundernode_config_1.OperationType.SUBSCRIPTION:
                        let subscriptionConfig = cfg.subscriptions(base);
                        if (customize) {
                            subscriptionConfig = customize(subscriptionConfig);
                        }
                        return {
                            ...op,
                            AuthenticationConfig: {
                                ...op.AuthenticationConfig,
                                required: subscriptionConfig.authentication.required,
                            }
                        };
                    default:
                        return op;
                }
            });
        }
        if (!isProduction && config.mock) {
            configureMock(app, config.mock)
                .then(() => {
                console.log("mock server running");
            })
                .catch(e => {
                console.log("mock server failed", e.toString());
            });
        }
        //watchFiles.push(operationsFileName)
        if (config.codeGenerators) {
            config.codeGenerators.forEach(gen => {
                codegen_1.GenerateCode({
                    wunderGraphConfig: resolved,
                    templates: gen.templates,
                    basePath: gen.path || "generated",
                });
            });
        }
        fs_1.default.writeFile(outFile, ResolvedWunderGraphConfigToJSON(resolved), err => {
            if (err !== null) {
                console.log(err);
                return;
            }
        });
        const dotGraphQLConfig = dotgraphqlconfig_1.generateDotGraphQLConfig(config, {
            baseURL: "http://localhost:9991",
        });
        fs_1.default.writeFile(".graphqlconfig", JSON.stringify(dotGraphQLConfig, null, "  "), err => {
            if (err != null) {
                console.log(err);
                return;
            }
        });
        console.log(`${new Date().toLocaleTimeString()}: wundergraph.config.json updated`);
    });
};
exports.configureWunderGraphApplication = configureWunderGraphApplication;
const ResolvedWunderGraphConfigToJSON = (config) => {
    const operations = config.application.Operations.map(op => ({
        content: op.Content,
        name: op.Name,
        responseSchema: JSON.stringify(op.ResponseSchema),
        variablesSchema: JSON.stringify(op.VariablesSchema),
        operationType: op.OperationType,
        mock: op.Mock ? {
            enabled: true,
            endpoint: op.Mock.Endpoint,
            subscriptionPollingIntervalMillis: op.Mock.SubscriptionPollingInterval || -1,
        } : { enabled: false, endpoint: "", subscriptionPollingIntervalMillis: -1 },
        cacheConfig: op.CacheConfig || {
            enable: false,
            maxAge: 0,
            public: false,
            staleWhileRevalidate: 0,
        },
        authenticationConfig: {
            authRequired: op.AuthorizationConfig.claims.length !== 0 || op.AuthenticationConfig.required,
        },
        authorizationConfig: op.AuthorizationConfig,
        liveQueryConfig: op.LiveQuery,
    }));
    const dataSources = config.application.EngineConfiguration.DataSources.map(mapDataSource);
    const fields = config.application.EngineConfiguration.Fields;
    const out = {
        apiName: config.deployment.api.name,
        apiId: config.deployment.api.id,
        deploymentName: config.deployment.name,
        environmentIds: [config.deployment.environment.id],
        api: {
            enableGraphqlEndpoint: false,
            operations: operations,
            engineConfiguration: {
                defaultFlushInterval: config.application.EngineConfiguration.DefaultFlushInterval,
                graphqlSchema: config.application.EngineConfiguration.Schema,
                datasourceConfigurations: dataSources,
                fieldConfigurations: fields,
            },
            corsConfiguration: config.application.CorsConfiguration,
            authenticationConfig: {
                cookieBased: {
                    providers: config.authentication.cookieBased,
                }
            }
        },
        dangerouslyEnableGraphQLEndpoint: config.enableGraphQLEndpoint,
    };
    return JSON.stringify(out, null, "  ");
};
const mapDataSource = (source) => {
    const out = {
        kind: source.Kind,
        customGraphql: undefined,
        rootNodes: source.RootNodes,
        childNodes: source.ChildNodes,
        customRest: undefined,
        customStatic: undefined,
        overrideFieldPathFromAlias: source.Kind === wundernode_config_1.DataSourceKind.GRAPHQL,
        customDatabase: undefined,
    };
    switch (source.Kind) {
        case wundernode_config_1.DataSourceKind.REST:
            const rest = source.Custom;
            out.customRest = {
                fetch: rest.Fetch,
                subscription: {
                    enabled: rest.Subscription.Enabled,
                    pollingIntervalMillis: rest.Subscription.PollingIntervalMillis || 500,
                    skipPublishSameResponse: rest.Subscription.SkipPublishSameResponse || false,
                }
            };
            break;
        case wundernode_config_1.DataSourceKind.STATIC:
            break;
        case wundernode_config_1.DataSourceKind.GRAPHQL:
            const graphql = source.Custom;
            out.customGraphql = {
                fetch: graphql.Fetch,
                federation: {
                    enabled: graphql.Federation.Enabled,
                    serviceSdl: graphql.Federation.ServiceSDL,
                },
                subscription: {
                    enabled: graphql.Subscription.Enabled,
                    url: graphql.Subscription.URL || "",
                }
            };
            break;
        case wundernode_config_1.DataSourceKind.POSTGRESQL:
        case wundernode_config_1.DataSourceKind.MYSQL:
        case wundernode_config_1.DataSourceKind.MONGODB:
        case wundernode_config_1.DataSourceKind.SQLSERVER:
            const database = source.Custom;
            out.customDatabase = {
                databaseQuerystring: database.database_querystring,
                prismaSchema: database.prisma_schema,
                graphqlSchema: database.graphql_schema,
            };
    }
    return out;
};
const configureMock = async (app, mock) => {
    if (app.Operations.length === 0) {
        return;
    }
    const totalQueries = mock.queries !== undefined ? Object.keys(mock.queries).length : 0;
    const totalMutations = mock.mutations !== undefined ? Object.keys(mock.mutations).length : 0;
    const totalSubscriptions = mock.subscriptions !== undefined ? Object.keys(mock.subscriptions).length : 0;
    const totalMocks = totalQueries + totalMutations + totalSubscriptions;
    if (totalMocks === 0) {
        return;
    }
    const mockServer = fastify_1.default({
        logger: false,
    });
    mockServer.addContentTypeParser('application/json', { parseAs: 'string' }, function (req, body, done) {
        try {
            var json = JSON.parse(body);
            done(null, json);
        }
        catch (err) {
            err.statusCode = 400;
            done(err, undefined);
        }
    });
    const port = await get_port_1.default({ port: [9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999], host: "127.0.0.1" });
    Object.keys(mock.queries || {}).forEach(operationName => {
        const operation = app.Operations.find(op => op.OperationType === wundernode_config_1.OperationType.QUERY && op.Name === operationName);
        if (!operation) {
            return;
        }
        operation.Mock = {
            Endpoint: `http://localhost:${port}/${operationName}`
        };
        const resolver = mock.queries[operationName];
        mockServer.post("/" + operationName, (request, reply) => {
            const response = resolver(request.body);
            if (response !== undefined) {
                reply.code(200);
                reply.send(response);
                return;
            }
            reply.code(404);
            reply.send();
        });
    });
    Object.keys(mock.mutations || {}).forEach(operationName => {
        const operation = app.Operations.find(op => op.OperationType === wundernode_config_1.OperationType.MUTATION && op.Name === operationName);
        if (!operation) {
            return;
        }
        operation.Mock = {
            Endpoint: `http://localhost:${port}/${operationName}`
        };
        const resolver = mock.mutations[operationName];
        mockServer.post("/" + operationName, (request, reply) => {
            const response = resolver(request.body);
            if (response !== undefined) {
                reply.code(200);
                reply.send(response);
                return;
            }
            reply.code(404);
            reply.send();
        });
    });
    Object.keys(mock.subscriptions || {}).forEach(operationName => {
        const operation = app.Operations.find(op => op.OperationType === wundernode_config_1.OperationType.SUBSCRIPTION && op.Name === operationName);
        if (!operation) {
            return;
        }
        operation.Mock = {
            Endpoint: `http://localhost:${port}/${operationName}`,
            SubscriptionPollingInterval: mock.subscriptions[operationName].pollingIntervalMillis,
        };
        const resolver = mock.subscriptions[operationName].resolver;
        mockServer.post("/" + operationName, (request, reply) => {
            const response = resolver(request.body);
            if (response !== undefined) {
                reply.code(200);
                reply.send(response);
                return;
            }
            reply.code(404);
            reply.send();
        });
    });
    await mockServer.listen({
        host: "localhost",
        port: port,
    });
    return mockServer;
};
