"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openApiSpecificationToRESTApiObject = void 0;
const definition_1 = require("../definition");
const swagger2openapi_1 = __importDefault(require("swagger2openapi"));
const graphql_1 = require("graphql");
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const js_yaml_1 = __importDefault(require("js-yaml"));
const openApiSpecificationToRESTApiObject = async (oas, introspection) => {
    try {
        const specObject = JSON.parse(oas, fixOasReplacer);
        const spec = await convertOpenApiV3(specObject);
        const builder = new RESTApiBuilder(spec, introspection);
        return builder.build();
    }
    catch (e) {
        const obj = js_yaml_1.default.load(oas);
        if (obj) {
            const spec = await convertOpenApiV3(obj);
            const builder = new RESTApiBuilder(spec, introspection);
            return builder.build();
        }
        throw new Error("cannot read OAS");
    }
};
exports.openApiSpecificationToRESTApiObject = openApiSpecificationToRESTApiObject;
class RESTApiBuilder {
    constructor(spec, introspection) {
        this.headers = {};
        this.dataSources = [];
        this.fields = [];
        this.build = () => {
            Object.keys(this.spec.paths).forEach(path => {
                const pathObject = this.spec.paths[path];
                if (pathObject.get) {
                    this.traversePath(pathObject.get, pathObject, path, wundernode_config_1.HTTPMethod.GET);
                }
                if (pathObject.post) {
                    this.traversePath(pathObject.post, pathObject, path, wundernode_config_1.HTTPMethod.POST);
                }
                if (pathObject.put) {
                    this.traversePath(pathObject.put, pathObject, path, wundernode_config_1.HTTPMethod.PUT);
                }
                if (pathObject.delete) {
                    this.traversePath(pathObject.delete, pathObject, path, wundernode_config_1.HTTPMethod.DELETE);
                }
            });
            const filtered = this.filterEmptyTypes(this.graphQLSchema);
            //const filtered = this.graphQLSchema;
            //const debug = print(filtered);
            const schema = graphql_1.buildASTSchema(filtered);
            const schemaString = graphql_1.printSchema(schema);
            return new definition_1.RESTApi(schemaString, this.dataSources, this.fields);
        };
        this.traversePath = (operationObject, pathItemObject, path, verb) => {
            const fieldName = this.prettyFieldName(this.resolveFieldName(operationObject, path, verb));
            if (!operationObject.responses) {
                console.log("handle empty response");
                return;
            }
            const parentType = verb === wundernode_config_1.HTTPMethod.GET ? "Query" : "Mutation";
            this.dataSources.push({
                RootNodes: [
                    {
                        typeName: parentType,
                        fieldNames: [fieldName]
                    }
                ],
                Kind: wundernode_config_1.DataSourceKind.REST,
                Custom: {
                    Fetch: {
                        method: verb,
                        url: this.buildURL(path),
                        body: "",
                        header: this.headers,
                        query: [],
                        upstreamAuthentication: definition_1.buildUpstreamAuthentication(this.httpUpstream),
                    },
                    Subscription: {
                        Enabled: false,
                    }
                },
                ChildNodes: [],
            });
            this.fields.push({
                typeName: parentType,
                fieldName: fieldName,
                disableDefaultFieldMapping: true,
                argumentsConfiguration: [],
                requiresFields: [],
                path: [],
                respectOverrideFieldPathFromAlias: false,
            });
            if (Object.keys(operationObject.responses).length === 0) {
                this.ensureType("scalar", "JSON");
                this.addField(parentType, "type", fieldName, "JSON", []);
            }
            Object.keys(operationObject.responses).forEach(statusCode => {
                if (statusCode !== "200") {
                    return;
                }
                const responseObject = this.resolveResponseObject(operationObject.responses[statusCode]);
                if (!responseObject) {
                    return;
                }
                if (!responseObject.content || !responseObject.content["application/json"]) {
                    return;
                }
                const mediaTypeObject = responseObject.content["application/json"];
                const schema = mediaTypeObject.schema;
                this.traverseSchema({
                    isRootField: true,
                    parentTypeName: parentType,
                    fieldName: fieldName,
                    schema: schema,
                    path: path,
                    verb: verb,
                    objectKind: "type",
                    enclosingTypes: [],
                });
            });
            const parameters = [...pathItemObject.parameters || [], ...operationObject.parameters || []];
            parameters.map(this.resolveParamsObject).forEach(param => {
                if (!param) {
                    return;
                }
                const schema = param.schema;
                this.traverseSchema({
                    parentTypeName: parentType,
                    fieldName: fieldName,
                    argumentName: param.name,
                    schema,
                    isRootField: true,
                    verb,
                    path,
                    objectKind: "input",
                    enclosingTypes: param.required ? ["non_null"] : [],
                });
                switch (param.in) {
                    case "query":
                        this.dataSources[this.dataSources.length - 1].Custom.Fetch.query = [
                            ...this.dataSources[this.dataSources.length - 1].Custom.Fetch.query || [],
                            {
                                name: param.name,
                                value: `{{ .arguments.${param.name} }}`
                            }
                        ];
                        break;
                    case "header":
                        this.dataSources[this.dataSources.length - 1].Custom.Fetch.header = {
                            ...this.dataSources[this.dataSources.length - 1].Custom.Fetch.header,
                            [param.name]: {
                                values: [`{{ .arguments.${param.name} }`]
                            },
                        };
                        break;
                    case "path":
                        this.dataSources[this.dataSources.length - 1].Custom.Fetch.url =
                            this.dataSources[this.dataSources.length - 1].Custom.Fetch.url.replace(`{${param.name}}`, `{{ .arguments.${param.name} }}`);
                        break;
                    case "cookie":
                        console.log("param.in not implemented for cookie");
                        break;
                }
            });
            if (operationObject.requestBody) {
                const body = this.resolveRequestBody(operationObject.requestBody);
                if (!body) {
                    return;
                }
                if (!body.content["application/json"]) {
                    return;
                }
                const applicationJSON = body.content["application/json"];
                const schema = applicationJSON.schema;
                const argumentName = this.resolveArgumentName(schema, path, verb);
                this.traverseSchema({
                    argumentName: argumentName,
                    fieldName: fieldName,
                    enclosingTypes: body.required ? ["non_null"] : [],
                    parentTypeName: parentType,
                    isRootField: true,
                    objectKind: "type",
                    path,
                    verb,
                    schema,
                });
                this.dataSources[this.dataSources.length - 1].Custom.Fetch.body = "{{ .arguments.input }}";
            }
        };
        this.traverseSchema = (options) => {
            let { argumentName, schema, objectKind, enclosingTypes, parentTypeName, fieldName, path, verb } = options;
            schema = this.resolveSingleSchemaOneOf(schema);
            const ref = this.resolveSchemaRef(schema);
            if (ref) {
                const componentSchema = this.spec.components && this.spec.components.schemas && this.spec.components.schemas[ref];
                if (!componentSchema) {
                    return;
                }
                if (argumentName) {
                    this.addArgument(parentTypeName, fieldName, argumentName, ref, enclosingTypes);
                }
                else {
                    this.addField(parentTypeName, objectKind, fieldName, ref, enclosingTypes);
                }
                const created = this.ensureType(componentSchema.enum ? "enum" : objectKind, ref);
                if (!created) {
                    return;
                }
                this.traverseSchema({
                    isRootField: false,
                    objectKind,
                    schema: componentSchema,
                    enclosingTypes: [],
                    parentTypeName: ref,
                    fieldName: "",
                    verb,
                    path,
                });
                return;
            }
            if (schema.allOf) {
                schema = schema.allOf.map(this.resolveSchema).reduce(this.mergeJSONSchemas);
            }
            if (schema.type === undefined) {
                this.ensureType("scalar", "JSON");
                if (argumentName) {
                    this.addArgument(parentTypeName, fieldName, argumentName, "JSON", enclosingTypes);
                    return;
                }
                this.addField(parentTypeName, objectKind, fieldName, "JSON", enclosingTypes);
                return;
            }
            switch (schema.type) {
                case "integer":
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "Int", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "Int", enclosingTypes);
                    return;
                case "null":
                    return;
                case "string":
                    if (schema.enum) {
                        if (argumentName && schema.enum.constructor === Array && schema.enum.length !== 0 && typeof schema.enum[0] === "number") {
                            this.addArgument(parentTypeName, fieldName, argumentName, "Int", enclosingTypes);
                            return;
                        }
                        if (argumentName) {
                            this.ensureType("enum", fieldName);
                            this.addArgument(parentTypeName, fieldName, argumentName, argumentName, enclosingTypes);
                            this.addEnumValues(argumentName, schema.enum);
                            return;
                        }
                        this.addEnumValues(parentTypeName, schema.enum);
                        return;
                    }
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "String", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "String", enclosingTypes);
                    return;
                case "boolean":
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "Boolean", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "Boolean", enclosingTypes);
                    return;
                case "number":
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "Int", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "Int", enclosingTypes);
                    return;
                case "array":
                    this.traverseSchema({
                        ...options,
                        schema: schema.items,
                        enclosingTypes: [
                            ...enclosingTypes,
                            "list",
                        ]
                    });
                    return;
                case "object":
                    if (!schema.properties) {
                        return;
                    }
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, argumentName, enclosingTypes);
                        this.ensureType("input", argumentName);
                        Object.keys(schema.properties).forEach(prop => {
                            this.traverseSchema({
                                isRootField: false,
                                enclosingTypes: [],
                                fieldName: prop,
                                objectKind: "input",
                                parentTypeName: argumentName,
                                path,
                                verb,
                                schema: schema.properties[prop]
                            });
                        });
                        return;
                    }
                    if (fieldName !== "") {
                        let typeName = schema.title ? schema.title.replace(" ", "") : fieldName[0].toUpperCase() + fieldName.substring(1);
                        if (objectKind === "input") {
                            typeName += "Input";
                        }
                        this.addField(parentTypeName, objectKind, fieldName, typeName, enclosingTypes);
                        const created = this.ensureType(objectKind, typeName);
                        if (!created) {
                            return;
                        }
                        Object.keys(schema.properties).forEach(prop => {
                            this.traverseSchema({
                                isRootField: false,
                                enclosingTypes: [],
                                fieldName: prop,
                                objectKind: objectKind,
                                parentTypeName: typeName,
                                path,
                                verb,
                                schema: schema.properties[prop]
                            });
                        });
                        return;
                    }
                    Object.keys(schema.properties).forEach(prop => {
                        this.traverseSchema({
                            isRootField: false,
                            enclosingTypes: [],
                            fieldName: prop,
                            objectKind: objectKind,
                            parentTypeName: parentTypeName,
                            path,
                            verb,
                            schema: schema.properties[prop]
                        });
                    });
            }
        };
        this.ensureType = (objectKind, ref) => {
            const exists = this.graphQLSchema.definitions.find(value => {
                switch (objectKind) {
                    case "type":
                        return value.kind === "ObjectTypeDefinition" && value.name.value === ref;
                    case "input":
                        return value.kind === "InputObjectTypeDefinition" && value.name.value === ref;
                    case "enum":
                        return value.kind === "EnumTypeDefinition" && value.name.value === ref;
                    case "scalar":
                        return value.kind === "ScalarTypeDefinition" && value.name.value === ref;
                    default:
                        throw new Error("must implement objectKind");
                }
            }) !== undefined;
            if (exists) {
                return false;
            }
            let node;
            switch (objectKind) {
                case "type":
                    node = this.buildObjectTypeDefinitionNode(ref, []);
                    break;
                case "input":
                    node = this.buildInputObjectTypeDefinitionNode(ref, []);
                    break;
                case "enum":
                    node = this.buildEnumTypeDefinitionNode(ref, []);
                    break;
                case "scalar":
                    node = this.buildScalarTypeDefinitionNode(ref);
                    break;
            }
            if (!node) {
                return false;
            }
            this.graphQLSchema = {
                ...this.graphQLSchema,
                definitions: [
                    ...this.graphQLSchema.definitions,
                    node,
                ]
            };
            return true;
        };
        this.baseURL = () => {
            if (!this.spec.servers || this.spec.servers.length === 0) {
                throw new Error("OpenAPISpecification must contain server + url");
            }
            const secure = this.spec.servers.find(server => server.url.startsWith("https"));
            if (secure) {
                return secure.url;
            }
            return this.spec.servers[0].url;
        };
        this.buildURL = (path) => {
            const base = this.baseURL();
            return base + path;
        };
        this.buildScalarTypeDefinitionNode = (name) => {
            return {
                kind: "ScalarTypeDefinition",
                name: {
                    kind: "Name",
                    value: name,
                },
            };
        };
        this.addArgument = (typeName, fieldName, argumentName, argumentType, enclosingTypes) => {
            const resolvedArgType = this.resolveTypeNode(argumentType, enclosingTypes);
            let done = false;
            this.graphQLSchema = graphql_1.visit(this.graphQLSchema, {
                ObjectTypeDefinition: node => {
                    if (node.name.value !== typeName) {
                        return false;
                    }
                },
                FieldDefinition: {
                    enter: node => {
                        if (node.name.value !== fieldName) {
                            return;
                        }
                        const update = {
                            ...node,
                            arguments: [
                                ...node.arguments || [],
                                {
                                    kind: "InputValueDefinition",
                                    name: {
                                        kind: "Name",
                                        value: argumentName,
                                    },
                                    type: resolvedArgType,
                                }
                            ],
                        };
                        done = true;
                        return update;
                    },
                },
            });
        };
        this.addField = (parentName, objectKind, fieldName, fieldTypeName, enclosingTypes) => {
            const fieldType = this.resolveTypeNode(fieldTypeName, enclosingTypes);
            if (objectKind === "type") {
                this.graphQLSchema = graphql_1.visit(this.graphQLSchema, {
                    ObjectTypeDefinition: node => {
                        if (node.name.value !== parentName) {
                            return;
                        }
                        const updated = {
                            ...node,
                            fields: [
                                ...node.fields || [],
                                {
                                    kind: "FieldDefinition",
                                    name: {
                                        kind: "Name",
                                        value: fieldName,
                                    },
                                    type: fieldType,
                                }
                            ]
                        };
                        return updated;
                    }
                });
            }
            else if (objectKind === "input") {
                this.graphQLSchema = graphql_1.visit(this.graphQLSchema, {
                    InputObjectTypeDefinition: node => {
                        if (node.name.value !== parentName) {
                            return;
                        }
                        const updated = {
                            ...node,
                            fields: [
                                ...node.fields || [],
                                {
                                    kind: "InputValueDefinition",
                                    name: {
                                        kind: "Name",
                                        value: fieldName,
                                    },
                                    type: fieldType,
                                }
                            ]
                        };
                        return updated;
                    }
                });
            }
        };
        this.addEnumValues = (enumTypeName, values) => {
            const nodes = [];
            values.forEach(value => {
                if (typeof value !== "string") {
                    return;
                }
                const exists = nodes.find(node => node.name.value === value) !== undefined;
                if (exists) {
                    return;
                }
                nodes.push({
                    kind: "EnumValueDefinition",
                    name: {
                        kind: "Name",
                        value: value,
                    },
                });
            });
            if (nodes.length === 0) {
                return;
            }
            this.graphQLSchema = graphql_1.visit(this.graphQLSchema, {
                EnumTypeDefinition: node => {
                    if (node.name.value !== enumTypeName) {
                        return;
                    }
                    const update = {
                        ...node,
                        values: [
                            ...node.values || [],
                            ...nodes,
                        ]
                    };
                    return update;
                }
            });
        };
        this.resolveTypeNode = (namedTypeName, enclosingTypes) => {
            if (enclosingTypes.length !== 0) {
                const first = enclosingTypes.shift();
                switch (first) {
                    case "list":
                        return {
                            kind: "ListType",
                            type: this.resolveTypeNode(namedTypeName, enclosingTypes)
                        };
                    case "non_null":
                        return {
                            kind: "NonNullType",
                            type: this.resolveTypeNode(namedTypeName, enclosingTypes)
                        };
                }
            }
            return {
                kind: "NamedType",
                name: {
                    kind: "Name",
                    value: namedTypeName,
                }
            };
        };
        this.resolveSingleSchemaOneOf = (schema) => {
            if (schema.oneOf && schema.oneOf.length === 1) {
                return schema.oneOf[0];
            }
            return schema;
        };
        this.resolveParamsObject = (object) => {
            if (object.$ref) {
                const ref = object.$ref;
                if (this.spec.components && this.spec.components.parameters)
                    return this.spec.components.parameters[ref];
                return undefined;
            }
            return object;
        };
        this.resolveRequestBody = (request) => {
            if (request.$ref) {
                const ref = request.$ref;
                if (this.spec.components && this.spec.components.requestBodies) {
                    return this.spec.components.requestBodies[ref];
                }
            }
            return request;
        };
        this.resolveResponseObject = (responseObject) => {
            const ref = responseObject.$ref || undefined;
            if (ref) {
                const schemaName = this.componentName(ref, "responses");
                if (!schemaName) {
                    return;
                }
                const resolvedSchema = this.spec.components && this.spec.components.responses && this.spec.components.responses[schemaName];
                if (!resolvedSchema) {
                    return;
                }
                if (resolvedSchema.$ref) {
                    return;
                }
                return resolvedSchema;
            }
            return responseObject;
        };
        this.filterEmptyTypes = (document) => {
            return graphql_1.visit(document, {
                ObjectTypeDefinition: node => {
                    if (!node.fields || node.fields.length === 0) {
                        return null;
                    }
                },
                InterfaceTypeDefinition: node => {
                    if (!node.fields || node.fields.length === 0) {
                        return null;
                    }
                },
                EnumTypeDefinition: node => {
                    if (!node.values || node.values.length === 0) {
                        return null;
                    }
                },
                UnionTypeDefinition: node => {
                    if (!node.types || node.types.length === 0) {
                        return null;
                    }
                }
            });
        };
        this.resolveSchema = (value) => {
            if (value.$ref) {
                const refPath = value.$ref.substring(2).split("/");
                if (refPath.length !== 3 || refPath[0] !== "components" || refPath[1] !== "schemas") {
                    return {};
                }
                const typeName = refPath[2];
                if (!this.spec.components || !this.spec.components.schemas) {
                    return {};
                }
                const schema = this.spec.components.schemas[typeName];
                return this.resolveSchema(schema);
            }
            if (value.oneOf && value.oneOf.length === 1) {
                return this.resolveSchema(value.oneOf[0]);
            }
            if (value.allOf) {
                return value.allOf.map(this.resolveSchema).reduce(this.mergeJSONSchemas);
            }
            return value;
        };
        this.componentName = (ref, componentType) => {
            if (ref.startsWith("#/")) {
                const refPath = ref.substring(2).split("/");
                if (refPath.length !== 3 || refPath[0] !== "components" || refPath[1] !== componentType) {
                    return;
                }
                return refPath[2];
            }
        };
        this.resolveSchemaRef = (schema) => {
            if (schema.$ref && schema.$ref.startsWith("#/")) {
                const refPath = schema.$ref.substring(2).split("/");
                if (refPath.length !== 3 || refPath[0] !== "components" || refPath[1] !== "schemas") {
                    return;
                }
                return refPath[2];
            }
        };
        this.mergeJSONSchemas = (previous, next) => {
            if (previous.type !== next.type) {
                return previous;
            }
            return {
                ...previous,
                properties: {
                    ...previous.properties,
                    ...next.properties,
                },
                required: [
                    ...(previous.required || []),
                    ...(next.required || [])
                ],
                additionalProperties: previous.additionalProperties || next.additionalProperties,
            };
        };
        this.buildObjectTypeDefinitionNode = (name, fields) => {
            return {
                kind: "ObjectTypeDefinition",
                fields: fields,
                name: {
                    kind: "Name",
                    value: name,
                }
            };
        };
        this.buildInputObjectTypeDefinitionNode = (name, fields) => {
            return {
                kind: "InputObjectTypeDefinition",
                fields: fields,
                name: {
                    kind: "Name",
                    value: name,
                }
            };
        };
        this.buildEnumTypeDefinitionNode = (name, values) => {
            return {
                kind: "EnumTypeDefinition",
                values,
                name: {
                    kind: "Name",
                    value: name,
                }
            };
        };
        this.prettyFieldName = (input) => {
            const underscore = input.split("_").reduce((prev, next) => prev + next[0].toUpperCase() + next.substring(1));
            return underscore.split("-").reduce((prev, next) => prev + next[0].toUpperCase() + next.substring(1));
        };
        this.resolveFieldName = (operationObject, path, verb) => {
            if (operationObject.operationId) {
                if (operationObject.operationId.startsWith("/")) {
                    return operationObject.operationId.substring(1);
                }
                return operationObject.operationId;
            }
            const formattedPath = path.split("/").filter(element => element !== "")
                .reduce((prev, current) => {
                if (current.startsWith("{") && current.endsWith("}")) {
                    const trimmed = current.substring(1, current.length - 1);
                    return prev + "By" + trimmed[0].toUpperCase() + trimmed.substring(1);
                }
                return prev + current[0].toUpperCase() + current.substring(1);
            });
            return wundernode_config_1.hTTPMethodToJSON(verb).toLowerCase() + formattedPath[0].toUpperCase() + formattedPath.substring(1);
        };
        this.spec = spec;
        this.graphQLSchema = {
            kind: "Document",
            definitions: [
                this.buildObjectTypeDefinitionNode("Query", []),
                this.buildObjectTypeDefinitionNode("Mutation", []),
                this.buildObjectTypeDefinitionNode("Subscription", []),
            ]
        };
        this.httpUpstream = introspection;
        if (introspection.headers) {
            Object.keys(introspection.headers).forEach(key => {
                this.headers[key] = {
                    values: [introspection.headers[key]],
                };
            });
        }
    }
    resolveArgumentName(schema, path, verb) {
        if (schema.title) {
            return schema.title.replace(" ", "") + "Input";
        }
        const formattedPath = path.split("/").reduce((prev, current) => prev + current[0].toUpperCase() + current.substring(1));
        return wundernode_config_1.hTTPMethodToJSON(verb).toLowerCase() + formattedPath[0] + formattedPath.substring(1) + "Input";
    }
}
const convertOpenApiV3 = async (openApiSpec) => {
    const converted = await swagger2openapi_1.default.convertObj(openApiSpec, {});
    return converted.openapi;
};
const fixOasReplacer = (key, value) => {
    switch (key) {
        case "$type":
            // remove the field
            return undefined;
        case "oneOf":
        case "allOf":
        case "anyOf":
        case "enum":
            if (value.constructor === Array) {
                return value;
            }
            if (value["$values"] !== undefined) {
                return value["$values"];
            }
            return value;
        default:
            return value;
    }
};
