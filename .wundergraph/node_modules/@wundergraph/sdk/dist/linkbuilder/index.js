"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceFieldStep = exports.typesInfo = exports.queryTypeFields = void 0;
const queryTypeFields = (schema) => {
    const info = [];
    const queryType = schema.getQueryType();
    if (!queryType) {
        return info;
    }
    const fields = queryType.getFields();
    if (!fields) {
        return info;
    }
    Object.keys(fields).forEach(key => {
        const field = fields[key];
        const name = field.name;
        info.push({
            typeName: queryType.name,
            fieldName: name,
            fieldType: field.type.toString(),
            arguments: field.args.map(arg => ({
                name: arg.name,
                type: arg.type.toString(),
            })),
        });
    });
    return info;
};
exports.queryTypeFields = queryTypeFields;
const typesInfo = (schema) => {
    const typeNames = [];
    const types = schema.getTypeMap();
    const queryTypeName = (schema.getQueryType() || { name: "" }).name;
    const mutationTypeName = (schema.getMutationType() || { name: "" }).name;
    const subscriptionTypeName = (schema.getSubscriptionType() || { name: "" }).name;
    Object.keys(types).forEach(key => {
        const type = types[key];
        if (type.astNode && (type.astNode.kind === "InterfaceTypeDefinition" || type.astNode.kind === "ObjectTypeDefinition")) {
            if (type.name !== queryTypeName && type.name !== mutationTypeName && type.name !== subscriptionTypeName) {
                typeNames.push({
                    typeName: type.name,
                    fieldNames: (type.astNode.fields || []).map(value => value.name.value),
                });
            }
        }
    });
    return typeNames;
};
exports.typesInfo = typesInfo;
// manually built link builder, re-used in code generator
class LinkBuilder {
    // @ts-ignore
    constructor(current = {}, sourceField, targetType, targetField) {
        // @ts-ignore
        this.current = {};
        this.build = () => {
            const args = this.current;
            return {
                argumentSources: Object.keys(args).map(key => ({
                    name: key,
                    type: args[key].source,
                    path: args[key].path,
                })),
                targetType: this.targetType,
                sourceField: this.sourceField,
                targetFieldName: this.targetField,
            };
        };
        this.current = current;
        this.sourceField = sourceField;
        this.targetType = targetType;
        this.targetField = targetField;
    }
    argument(key, source, value, ...extraPath) {
        const extra = { [key]: { source, path: [value, ...extraPath] } };
        const instance = {
            ...this.current,
            ...extra
        };
        return new LinkBuilder(instance, this.sourceField, this.targetType, this.targetField);
    }
}
const sourceFieldStep = () => ({
    source: (field) => {
        return targetTypeStep(field);
    },
});
exports.sourceFieldStep = sourceFieldStep;
const targetTypeStep = (field) => ({
    target: (targetType, targetField) => {
        return new LinkBuilder({}, field, targetType, targetField);
    }
});
const builder = exports.sourceFieldStep()
    .source("user")
    .target("User", "userUser")
    .argument("age", "fieldArgument", "userAge")
    .argument("name", "objectField", "id")
    .build();
