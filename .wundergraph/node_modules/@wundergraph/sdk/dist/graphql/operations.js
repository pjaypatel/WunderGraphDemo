"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadOperations = exports.operationResponseToJSONSchema = exports.operationVariablesToJSONSchema = exports.parseOperations = void 0;
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const graphql_1 = require("graphql");
const os_1 = __importDefault(require("os"));
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const defaultParseOptions = {
    keepFromClaimVariables: false,
};
const parseOperations = (graphQLSchema, operationsDocument, options = defaultParseOptions) => {
    const parsedGraphQLSchema = graphql_1.buildSchema(graphQLSchema);
    const parsed = {
        operations: []
    };
    try {
        const ast = graphql_1.parse(operationsDocument);
        graphql_1.visit(ast, {
            OperationDefinition: {
                enter: node => {
                    var _a;
                    const operationName = (node.name || { value: "" }).value;
                    const operation = {
                        Name: operationName,
                        Content: graphql_1.print(node),
                        OperationType: parseOperationTypeNode(node.operation),
                        VariablesSchema: exports.operationVariablesToJSONSchema(parsedGraphQLSchema, node, 2, options.keepFromClaimVariables),
                        ResponseSchema: exports.operationResponseToJSONSchema(parsedGraphQLSchema, ast, node),
                        AuthenticationConfig: {
                            required: false,
                        },
                        AuthorizationConfig: {
                            claims: [],
                        }
                    };
                    (_a = node.variableDefinitions) === null || _a === void 0 ? void 0 : _a.forEach(variable => {
                        var _a;
                        const variableName = variable.variable.name.value;
                        const fromClaimDirective = (_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "fromClaim");
                        if (fromClaimDirective === undefined || fromClaimDirective.arguments === undefined) {
                            return;
                        }
                        const nameArg = fromClaimDirective.arguments.find(arg => arg.name.value === "name");
                        if (nameArg === undefined) {
                            return;
                        }
                        if (nameArg.value.kind !== "EnumValue") {
                            return;
                        }
                        const name = nameArg.value.value;
                        switch (name) {
                            case "EMAIL":
                                operation.AuthenticationConfig.required = true;
                                operation.AuthorizationConfig.claims.push({
                                    variableName,
                                    claim: wundernode_config_1.Claim.EMAIL
                                });
                                break;
                            case "EMAIL_VERIFIED":
                                operation.AuthenticationConfig.required = true;
                                operation.AuthorizationConfig.claims.push({
                                    variableName,
                                    claim: wundernode_config_1.Claim.EMAIL_VERIFIED
                                });
                                break;
                            case "NAME":
                                operation.AuthenticationConfig.required = true;
                                operation.AuthorizationConfig.claims.push({
                                    variableName,
                                    claim: wundernode_config_1.Claim.NAME
                                });
                                break;
                            case "NICKNAME":
                                operation.AuthenticationConfig.required = true;
                                operation.AuthorizationConfig.claims.push({
                                    variableName,
                                    claim: wundernode_config_1.Claim.NICKNAME
                                });
                                break;
                            case "LOCATION":
                                operation.AuthenticationConfig.required = true;
                                operation.AuthorizationConfig.claims.push({
                                    variableName,
                                    claim: wundernode_config_1.Claim.LOCATION
                                });
                                break;
                            case "PROVIDER":
                                operation.AuthenticationConfig.required = true;
                                operation.AuthorizationConfig.claims.push({
                                    variableName,
                                    claim: wundernode_config_1.Claim.PROVIDER
                                });
                                break;
                        }
                    });
                    parsed.operations.push(operation);
                }
            }
        });
    }
    catch (e) {
        console.log("Cannot parse Operations, please add at least one named operation to the wundergraph.*.operations.graphql file.");
    }
    return parsed;
};
exports.parseOperations = parseOperations;
const parseOperationTypeNode = (node) => {
    switch (node) {
        case "subscription":
            return wundernode_config_1.OperationType.SUBSCRIPTION;
        case "mutation":
            return wundernode_config_1.OperationType.MUTATION;
        case "query":
            return wundernode_config_1.OperationType.QUERY;
        default:
            return -1;
    }
};
const operationVariablesToJSONSchema = (graphQLSchema, operation, maxDepth = 2, keepFromClaimVariables = false) => {
    const schema = {
        type: "object",
        properties: {},
        additionalProperties: false,
    };
    if (!operation.variableDefinitions) {
        return schema;
    }
    operation.variableDefinitions.forEach(variable => {
        var _a;
        const hasFromClaimDirective = ((_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "fromClaim")) !== undefined;
        if (hasFromClaimDirective && !keepFromClaimVariables) {
            return;
        }
        let type = variable.type;
        if (type.kind === "NonNullType" && variable.defaultValue !== undefined) {
            type = type.type;
        }
        const name = variable.variable.name.value;
        schema.properties[name] = typeSchema(schema, graphQLSchema, maxDepth, 0, type, name);
    });
    return schema;
};
exports.operationVariablesToJSONSchema = operationVariablesToJSONSchema;
const typeSchema = (parent, graphQLSchema, maxDepth, depth, type, name) => {
    switch (type.kind) {
        case "NonNullType":
            switch (parent.type) {
                case "object":
                    parent.required = [...parent.required || [], name];
                    break;
                case "array":
                    parent.minItems = 1;
                    break;
            }
            return typeSchema(parent, graphQLSchema, maxDepth, depth, type.type, name);
        case "ListType":
            const schema = {
                type: "array",
            };
            schema.items = typeSchema(schema, graphQLSchema, maxDepth, depth, type.type, name);
            return schema;
        case "NamedType":
            switch (type.name.value) {
                case 'Int':
                    return {
                        type: "integer"
                    };
                case 'Boolean':
                    return {
                        type: "boolean"
                    };
                case 'ID':
                    return {
                        type: "string"
                    };
                case 'Float':
                    return {
                        type: "number"
                    };
                case 'String':
                    return {
                        type: "string"
                    };
                default:
                    let schema = {};
                    const namedType = graphQLSchema.getType(type.name.value);
                    if (namedType === null || namedType === undefined || !namedType.astNode) {
                        return {};
                    }
                    if (depth > maxDepth) {
                        return {};
                    }
                    switch (namedType.astNode.kind) {
                        case "ScalarTypeDefinition":
                            return {
                                type: "string",
                            };
                        case "EnumTypeDefinition":
                            schema.type = "string";
                            schema.enum = (namedType.astNode.values || []).map(e => {
                                return e.name.value;
                            });
                            break;
                        case "InputObjectTypeDefinition":
                            schema.additionalProperties = false;
                            schema.type = "object";
                            schema.properties = {};
                            (namedType.astNode.fields || []).forEach(f => {
                                const name = f.name.value;
                                let fieldType = f.type;
                                if (f.defaultValue !== undefined && fieldType.kind === "NonNullType") {
                                    fieldType = fieldType.type;
                                }
                                schema.properties[name] = typeSchema(schema, graphQLSchema, maxDepth, depth + 1, fieldType, name);
                            });
                            break;
                    }
                    return schema;
            }
    }
    return {};
};
const operationResponseToJSONSchema = (graphQLSchema, operationDocument, operationNode) => {
    const dataSchema = {
        type: "object",
        properties: {},
        additionalProperties: false,
    };
    const schema = {
        type: "object",
        properties: {
            "data": dataSchema,
        },
        additionalProperties: false,
    };
    const typeName = operationRootTypeName(operationNode, graphQLSchema);
    resolveSelections(graphQLSchema, operationDocument, operationNode.selectionSet.selections, typeName, dataSchema);
    return schema;
};
exports.operationResponseToJSONSchema = operationResponseToJSONSchema;
const operationRootTypeName = (node, graphQLSchema) => {
    switch (node.operation) {
        case "query":
            return (graphQLSchema.getQueryType() || {}).name || "";
        case "mutation":
            return (graphQLSchema.getMutationType() || {}).name || "";
        case "subscription":
            return (graphQLSchema.getSubscriptionType() || {}).name || "";
        default:
            return "";
    }
};
const resolveSelections = (graphQLSchema, operationDocument, selections, parentTypeName, parentObject) => {
    const parentType = graphQLSchema.getType(parentTypeName);
    if (!parentType || !parentType.astNode) {
        return;
    }
    if (parentType.astNode.kind === "UnionTypeDefinition") {
        selections.forEach(selection => {
            switch (selection.kind) {
                case "Field":
                    const fieldName = selection.name.value;
                    const propName = selection.alias !== undefined ? selection.alias.value : selection.name.value;
                    if (fieldName !== "__typename") {
                        return;
                    }
                    parentObject.properties[propName] = {
                        type: "string"
                    };
                    return;
                case "InlineFragment":
                    if (!selection.typeCondition) {
                        return;
                    }
                    const typeName = selection.typeCondition.name.value;
                    resolveSelections(graphQLSchema, operationDocument, selection.selectionSet.selections, typeName, parentObject);
                    delete parentObject.required; // union root fields are always optional
                    return;
                case "FragmentSpread":
                    const fragmentDefinition = operationDocument.definitions.find(node => node.kind === "FragmentDefinition" && node.name.value === selection.name.value);
                    if (fragmentDefinition) {
                        const typeName = fragmentDefinition.typeCondition.name.value;
                        const selections = fragmentDefinition.selectionSet.selections;
                        resolveSelections(graphQLSchema, operationDocument, selections, typeName, parentObject);
                        delete parentObject.required; // union root fields are always optional
                        return;
                    }
            }
        });
        return;
    }
    if ((parentType.astNode.kind !== "ObjectTypeDefinition" && parentType.astNode.kind !== "InterfaceTypeDefinition") || !parentType.astNode.fields) {
        return;
    }
    selections.forEach(selection => {
        switch (selection.kind) {
            case "Field":
                const fieldName = selection.name.value;
                const propName = selection.alias !== undefined ? selection.alias.value : selection.name.value;
                const definition = parentType.astNode.fields.find(f => f.name.value === fieldName);
                if (!definition) {
                    return;
                }
                const schema = resolveFieldSchema(graphQLSchema, operationDocument, propName, selection, definition.type, parentObject);
                parentObject.properties[propName] = schema;
                break;
            case "FragmentSpread":
                const fragmentDefinition = operationDocument.definitions.find(node => node.kind === "FragmentDefinition" && node.name.value === selection.name.value);
                resolveSelections(graphQLSchema, operationDocument, fragmentDefinition.selectionSet.selections, parentTypeName, parentObject);
                break;
            case "InlineFragment":
                resolveSelections(graphQLSchema, operationDocument, selection.selectionSet.selections, parentTypeName, parentObject);
                break;
        }
    });
};
const resolveFieldSchema = (graphQLSchema, operationDocument, propName, field, fieldType, parent) => {
    switch (fieldType.kind) {
        case "NonNullType":
            switch (parent.type) {
                case "object":
                    parent.required = [...new Set([...parent.required || [], propName])];
                    return resolveFieldSchema(graphQLSchema, operationDocument, propName, field, fieldType.type, parent);
                case "array":
                    parent.minItems = 1;
                    return resolveFieldSchema(graphQLSchema, operationDocument, propName, field, fieldType.type, parent);
                default:
                    return {};
            }
        case "ListType":
            return {
                type: "array",
                items: resolveFieldSchema(graphQLSchema, operationDocument, propName, field, fieldType.type, parent)
            };
        case "NamedType":
            switch (fieldType.name.value) {
                case 'Int':
                    return {
                        type: "integer"
                    };
                case 'Boolean':
                    return {
                        type: "boolean"
                    };
                case 'ID':
                    return {
                        type: "string"
                    };
                case 'Float':
                    return {
                        type: "number"
                    };
                case 'String':
                    return {
                        type: "string"
                    };
                default:
                    let schema = {};
                    const namedType = graphQLSchema.getType(fieldType.name.value);
                    if (namedType === null || namedType === undefined || !namedType.astNode) {
                        return {};
                    }
                    switch (namedType.astNode.kind) {
                        case "ScalarTypeDefinition":
                            return {
                                type: "string",
                            };
                        case "EnumTypeDefinition":
                            schema.type = "string";
                            schema.enum = (namedType.astNode.values || []).map(e => {
                                return e.name.value;
                            });
                            break;
                        case "UnionTypeDefinition":
                        case "InterfaceTypeDefinition":
                        case "ObjectTypeDefinition":
                            schema.type = "object";
                            schema.properties = {};
                            schema.additionalProperties = false;
                            if (!field.selectionSet) {
                                return schema;
                            }
                            resolveSelections(graphQLSchema, operationDocument, field.selectionSet.selections, namedType.name, schema);
                            break;
                    }
                    return schema;
            }
    }
};
const loadOperations = () => {
    var _a, _b;
    const home = os_1.default.homedir();
    const cmd = path_1.default.join(home, ".wundergraph", "wunderctl");
    const operationsPath = path_1.default.join(process.cwd(), "operations");
    const result = child_process_1.spawnSync(cmd, ["loadoperations", operationsPath], {
        cwd: process.cwd(),
        encoding: "utf-8",
        timeout: 10000,
    });
    if (result.status !== 0) {
        return "";
    }
    const output = result.output.join("");
    const out = JSON.parse(output);
    (_a = out.info) === null || _a === void 0 ? void 0 : _a.forEach(info => console.log(JSON.stringify({ "level": "info", "message": info })));
    (_b = out.errors) === null || _b === void 0 ? void 0 : _b.forEach(info => console.log(JSON.stringify({ "level": "error", "message": info })));
    return out.files.map(file => file.content).join(" ");
};
exports.loadOperations = loadOperations;
