"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitJSONSchema = exports.mergeTemplateOutput = exports.GenerateCode = void 0;
const path_1 = __importDefault(require("path"));
const fs = __importStar(require("fs"));
class FileSystem {
    writeFileSync(path, content) {
        ensurePath(path);
        fs.writeFileSync(path, content);
    }
}
const ensurePath = (filePath) => {
    const dir = path_1.default.dirname(filePath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir);
    }
};
const GenerateCode = async (config, customOutWriter) => {
    config.templates.forEach(tmpl => {
        if (!tmpl.dependencies) {
            return;
        }
        const deps = tmpl.dependencies();
        config.templates.push(...deps);
    });
    const dedupedTemplates = [];
    config.templates.forEach(tmpl => {
        const exists = dedupedTemplates.find(value => value.constructor.name === tmpl.constructor.name) !== undefined;
        if (!exists) {
            dedupedTemplates.push(tmpl);
        }
    });
    const outWriter = customOutWriter || new FileSystem();
    const generators = [];
    dedupedTemplates.forEach(template => {
        generators.push(template.generate(config.wunderGraphConfig));
    });
    const resolved = await Promise.all(generators);
    const rawOutFiles = resolved.reduce((previousValue, currentValue) => ([...previousValue, ...currentValue]));
    const outFiles = exports.mergeTemplateOutput(rawOutFiles);
    outFiles.forEach(file => {
        const outPath = path_1.default.join(config.basePath, file.path);
        if (fs.existsSync(outPath)) {
            const existingContent = fs.readFileSync(outPath).toString();
            if (existingContent === file.content) {
                return;
            }
        }
        outWriter.writeFileSync(outPath, file.content);
    });
};
exports.GenerateCode = GenerateCode;
const mergeTemplateOutput = (outFiles) => {
    const merged = [];
    outFiles.forEach(file => {
        const existing = merged.find(out => out.path === file.path);
        if (existing) {
            existing.content += "\n\n" + file.content;
        }
        else {
            merged.push(file);
        }
    });
    merged.forEach(file => {
        while (file.content.search("\n\n\n") !== -1) {
            file.content = file.content.replace("\n\n\n", "\n\n");
        }
    });
    return merged;
};
exports.mergeTemplateOutput = mergeTemplateOutput;
const visitJSONSchema = (schema, visitor) => {
    visitor.root && visitor.root.enter && visitor.root.enter();
    visitProperties(schema, visitor);
    visitor.root && visitor.root.leave && visitor.root.leave();
};
exports.visitJSONSchema = visitJSONSchema;
const visitProperties = (schema, visitor) => {
    if (!schema.properties) {
        return;
    }
    Object.keys(schema.properties).forEach(key => {
        const isRequired = schema.required && schema.required.find(req => req === key) !== undefined || false;
        const propertySchema = schema.properties[key];
        visitSchema(propertySchema, visitor, key, isRequired, false);
    });
};
const visitSchema = (schema, visitor, propertyName, isRequired, isArray) => {
    switch (schema.type) {
        case "number":
            visitor.number && visitor.number(propertyName, isRequired, isArray);
            break;
        case "boolean":
            visitor.boolean && visitor.boolean(propertyName, isRequired, isArray);
            break;
        case "object":
            visitor.object && visitor.object.enter && visitor.object.enter(propertyName, isRequired, isArray);
            visitProperties(schema, visitor);
            visitor.object && visitor.object.leave && visitor.object.leave(propertyName, isRequired, isArray);
            break;
        case "string":
            visitor.string && visitor.string(propertyName, isRequired, isArray, schema.enum);
            break;
        case "array":
            visitor.array && visitor.array.enter && visitor.array.enter(propertyName, isRequired, isArray);
            visitSchema(schema.items, visitor, "", isRequired, true);
            visitor.array && visitor.array.leave && visitor.array.leave(propertyName, isRequired, isArray);
            break;
        case "integer":
            visitor.number && visitor.number(propertyName, isRequired, isArray);
            break;
    }
};
