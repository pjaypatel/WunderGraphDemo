"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadTemplate = exports.TypeScriptResponseModels = exports.TypeScriptInputModels = exports.formatTypeScript = void 0;
const index_1 = require("../../index");
const prettier_1 = __importDefault(require("prettier"));
const react_1 = require("./react");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const formatTypeScript = (input) => {
    return prettier_1.default.format(input, {
        parser: "typescript",
        printWidth: 120,
        useTabs: true,
        tabWidth: 2,
    });
};
exports.formatTypeScript = formatTypeScript;
class TypeScriptInputModels {
    async generate(config) {
        const content = config.application.Operations
            .filter(react_1.hasInput)
            .map(op => {
            return JSONSchemaToTypescriptInterface(op.VariablesSchema, op.Name + "Input", false);
        }).join("\n\n");
        return Promise.resolve([
            {
                path: "models.ts",
                content: exports.formatTypeScript(content),
            }
        ]);
    }
}
exports.TypeScriptInputModels = TypeScriptInputModels;
class TypeScriptResponseModels {
    generate(config) {
        const content = config.application.Operations.map(op => {
            return JSONSchemaToTypescriptInterface(op.ResponseSchema, op.Name + "Response", true);
        }).join("\n\n");
        const withErrorDefinition = graphQLErrorDefinition + "\n\n" + content;
        return Promise.resolve([
            {
                path: "models.ts",
                content: exports.formatTypeScript(withErrorDefinition),
            }
        ]);
    }
}
exports.TypeScriptResponseModels = TypeScriptResponseModels;
const graphQLErrorDefinition = `
export interface GraphQLError {
    message: string;
    path?: ReadonlyArray<string | number>;
}`;
const JSONSchemaToTypescriptInterface = (schema, interfaceName, withErrors) => {
    let out = "";
    const writeType = (name, isRequired, typeName) => {
        out += `${name + (isRequired ? "" : "?")}: ${typeName}\n`;
    };
    index_1.visitJSONSchema(schema, {
        root: {
            enter: () => {
                out += `export interface ${interfaceName} {\n`;
            },
            leave: () => {
                if (withErrors) {
                    out += `errors?: ReadonlyArray<GraphQLError>;\n`;
                }
                out += "}";
            }
        },
        number: (name, isRequired, isArray) => {
            if (isArray) {
                out += "number";
            }
            else {
                writeType(name, isRequired, "number");
            }
        },
        array: {
            enter: (name, isRequired, isArray) => {
                out += `${name + (isRequired ? "" : "?")}: `;
            },
            leave: (name, isRequired, isArray) => {
                out += "[],";
            },
        },
        string: (name, isRequired, isArray, enumValues) => {
            if (enumValues !== undefined) {
                const values = enumValues.map(v => `"${v}"`).join(" | ");
                if (isArray) {
                    out += values;
                }
                else {
                    writeType(name, isRequired, values);
                }
                return;
            }
            if (isArray) {
                out += "string";
            }
            else {
                writeType(name, isRequired, "string");
            }
        },
        object: {
            enter: (name, isRequired, isArray) => {
                if (isArray) {
                    out += "{\n";
                }
                else {
                    writeType(name, isRequired, "{");
                }
            },
            leave: (name, isRequired, isArray) => {
                out += "}";
                if (!isArray) {
                    out += ",\n";
                }
            }
        },
        boolean: (name, isRequired, isArray) => {
            if (isArray) {
                out += "boolean";
            }
            else {
                writeType(name, isRequired, "boolean");
            }
        }
    });
    return out;
};
const loadTemplate = (fileImport) => {
    if (typeof fileImport !== "string") {
        return fileImport();
    }
    return fs_1.default.readFileSync(path_1.default.resolve(__dirname, fileImport)).toString();
};
exports.loadTemplate = loadTemplate;
