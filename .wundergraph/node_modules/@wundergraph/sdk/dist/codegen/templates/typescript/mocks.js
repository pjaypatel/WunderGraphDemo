"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptMocks = void 0;
const handlebars_1 = __importDefault(require("handlebars"));
const index_1 = require("./index");
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const client_1 = require("./client");
// @ts-ignore
const mocks_ts_handlebars_1 = __importDefault(require("./mocks.ts.handlebars"));
class TypeScriptMocks {
    generate(config) {
        const input = index_1.loadTemplate(mocks_ts_handlebars_1.default);
        const tmpl = handlebars_1.default.compile(input);
        const _queries = client_1.operations(config.application, wundernode_config_1.OperationType.QUERY);
        const _mutations = client_1.operations(config.application, wundernode_config_1.OperationType.MUTATION);
        const _subscriptions = client_1.operations(config.application, wundernode_config_1.OperationType.SUBSCRIPTION);
        const content = tmpl({
            applicationName: config.application.Name,
            modelImports: client_1.modelImports(config.application),
            queries: _queries,
            hasQueries: _queries.length !== 0,
            mutations: _mutations,
            hasMutations: _mutations.length !== 0,
            subscriptions: _subscriptions,
            hasSubscriptions: _subscriptions.length !== 0,
        });
        return Promise.resolve([
            {
                path: "mocks.ts",
                content: index_1.formatTypeScript(content),
            }
        ]);
    }
    dependencies() {
        return [
            new index_1.TypeScriptInputModels(),
            new index_1.TypeScriptResponseModels(),
        ];
    }
}
exports.TypeScriptMocks = TypeScriptMocks;
